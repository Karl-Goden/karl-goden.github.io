
<style>
    p {
        font-size: 20px;
    }
</style>

<title>LLVM</title>
<h1>Chapter 0: Build</h1>
<b>LLVM_ENABLE_PROJECTS</b> run on host, target multiple architectures.<br>
<b>LLVM_TARGETS_TO_BUILD</b> indicate which project target to build.<br>
<b>LLVM_ENABLE_RUNTIMES</b> run on target, every architecture have its own.<br>
<b>LLVM_RUNTIME_TAEGETS</b> indicate which runtime target to build.

<h1>Chapter 1: IR</h1>

<h2>Section 1: Module</h2>
<h2>Section 2: Funtion</h2>
<h2>Section 3: Instruction</h2>

<h1>Chapter 2: Opt</h1>
<h2>Section 1: Analysis</h2>
<h2>Section 2: Transform</h2>
<h2>Section 3: Pass Manager</h2>

<h1>Chapter 3: CodeGen</h1>
<h2>Section 0: TableGen</h2>
<p>
    MCOperand:<br>
      EncoderMethod<br>
      DecoderMethod<br>
      PrinteMethod<br>
      OperandType<br>
      MCOperandPredicate<br>
      ParserMatchClass -> AsmOperandClass<br>
    <br>
    AsmOperandClass:<br>
      ParserMethod: create operand from asm.<br>
      RenderMethod: add operand into MCInst.<br>
      PredicateMethod: check if operand is valid after parse.<br>
</p>

<h2>Section 1: Instruction Selection</h2>
<p>
    <b>FastISel</b>
</p>
<p>
    <b>SelectionDAG:</b><br>
    TargetLowering is used to lower llvm ir to SDNode (builtin opcode and target opcode) when legalizing.<br>
    TargetISelDAGToDAG is used to lower previous SDNode to machine opcode by hand code or pattern matching when selecting.<br>
</p>
<p>
    <b>GlobalISel</b>
</p>

<h2>Section 2: Instruction Scheduling</h2>
<p>
    <b>InstrItineraryData</b> records the instruction execution stages and its operands use/def stage and bypass function.<br>
    <b>InstrStage</b> records an execution stage cost cycles, alternative function unit and how many cycles next stage begins.<br>
    Schedule function unit for structure harzard, use-def for data hazard.
</p>
<p>
    <b>TargetSchedModel</b> contains MCSchedModel and InstrItineraryData for instruction execution and memory latency.
</p>
<p>
    <b>ScheduleDAG</b> schedule SUnit based on its Preds and Succs SDep.
</p>
<p>
    <b>ScheduleDAGSDNodes</b> inherits ScheduleDAG to schedule SDNode. ScheduleDAGRRList, ScheduleDAGFast, ScheduleDAGLinearize and<br>
    ScheduleDAGVLIW all inherits ScheduleDAGSDNodes to apply different policies to schedule SDNode.
</p>
<p>
    <b>ScheduleDAGInstrs</b> inherits ScheduleDAG to schedule MachineInstr. ScheduleDAGMI inherits ScheduleDAGInstrs. ScheduleDAGMILive<br>
    inherits ScheduleDAGMI to schedule pre-ra MachineInstr keeping LiveIntervals and register pressure. The pre-ra MachineScheduler and<br>
    VLIWMachineScheduler use ScheduleMILive, post-ra PostMachineScheduler use ScheduleDAGMI. SwingSchedulerDAG, DefaultVLIWScheduler<br>
    and SchedulePostRATDList extends ScheduleDAGMI.
</p>
<p>
    <b>VLIWPacketizerList</b> in DFAPacketizer is used to packet the bundle of instructions. It contains a DefaultVLIWScheduler to only<br>
    create SUnit dependency graph and a DFAPacketizer to trace the capability of resources.
</p>

<h2>Section 3: Register Allocation</h2>
<p>
    <b>Fast</b>
</p>
<p>
    <b>Greedy</b>
</p>
<p>
    <b>PBQP</b>
</p>

<h1>Chapter 4: MC</h1>
<p>
    <b>MCSection</b> is basic part of object<br>
    <b>MCFragment</b> is subsection of MCSection.<br>
    <b>MCSymbol</b> is a named object.<br>
    <b>MCLabel</b> is an unnamed object.
</p>
<p>
    <b>MCCodeEmitter</b> is used to print an instruction into a binary format:<br>
    <code>void encodeInstruction(MCInst &Inst, vector&ltchar&gt &CB, vector&ltMCFixup&gt &Fixups, MCSubtargetInfo &STI)</code>
</p>
<p>
    <b>MCInstPrinter</b> is used to print an instruction in assembly format:<br>
    <code>void printInst(MCInst &Inst, uint64_t Address, StringRef Annot, MCSubtargetInfo &STI, raw_ostream &OS) </code>
</p>
<p>
    <b>MCObjectFileInfo</b> is used to store information about the object file being generated. Every binary format initializes its<br>
    own MCSection and its alignment.
</p>
<p>
    <b>AsmPrinter</b> is a codegen MachineFunctionPass that lower MIR to MC to assembly or object code. It is construced with an MCStreamer.<br>
    The MCAsmStreamer inherits MCStreamer for assembly output, and MCObjectStreamer for object code output which is also subclassed<br>
    by MCELFStreamer, MCMachOStreamer for different object formats which is also subclassed by different targets like RISCVELFStreamer,<br>
    X86ELFStreamer, etc. The MCStreamer contains a MCTargetStreamer which is used to emit target-specific directives (for assembly) and<br>
    data (for object) which is also subclassed by different targets like RISCVELFTargetStreamer.
</p>
<p>
    <b>MCAssembler</b> receive MCCodeEmitter, MCAsmBackend and MCObjectWriter to write the object code. MCCodeEmitter emit instruction.<br>
    MCAsmBackend create MCObjectWriter and apply MCFixup. MCObjectWriter write entire object file which is subclassed by different<br>
    binary formats like MCELFObjectWriter, MCMachOObjectWriter etc. These subclasses also has its own MCObjectTargetWriter which is<br>
    implementd by different targets like RISCVELFObjectWriter which is created by RISCVAsmBackend in order to create MCObjectWrtier.
</p>
<p>
    <b>MCFixup</b> is generated by MCCodeEmitter to record how to map upcoming symbol to the binary code. It is comsumed by MCAsmBackend<br>
    when then symbol is resolved or by MCObjectWriter to map it to object file relocation record when symbol will be resolved at link time<br>
    or load time.
</p>

<h1>References</h1>
<p>
Bulldog: A Compiler for VLIW Architectures by John R. Ellis.<br>
</p>